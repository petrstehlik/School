/*
 * Architektura procesoru (ACH 2016)
 * Projekt c. 2 (cuda)
 * Login: xlogin00
 */

#include <sys/time.h>
#include <cstdio>
#include <cmath>
#include <iostream>

#include "nbody.h"

typedef struct {
	float *arr_1;
	float *arr_2;
} test;

__global__ void kernel(test *t) {
	t->arr_1[1] += 5.2f;
	t->arr_2[1] += 5.2f;
}

int main(int argc, char **argv)
{
    FILE *fp;
    struct timeval t1, t2;
    int N;
    float dt;
    int steps;
    int thr_blc;


	float *h_arr_1, *h_arr_2;
	float *d_arr_1, *d_arr_2;
    // parametry
    if (argc != 7)
    {
        printf("Usage: nbody <N> <dt> <steps> <thr/blc> <input> <output>\n");
        exit(1);
    }
    N = atoi(argv[1]);
    dt = atof(argv[2]);
    steps = atoi(argv[3]);
    thr_blc = atoi(argv[4]);

    printf("N: %d\n", N);
    printf("dt: %f\n", dt);
    printf("steps: %d\n", steps);
    printf("threads/block: %d\n", thr_blc);

	h_arr_1 = new float[N]();
	h_arr_2 = new float[N]();

	h_arr_1[1] = 10.0f;
	h_arr_2[1] = 20.0f;

	cudaMalloc((void **) &d_arr_1, sizeof(float) * N);
	cudaMalloc((void **) &d_arr_2, sizeof(float) * N);

	test *dev_s;
	cudaMalloc((void **)&dev_s, sizeof(*dev_s));

	cudaMemcpy(d_arr_1, h_arr_1, sizeof(float) * N, cudaMemcpyHostToDevice);
	cudaMemcpy(d_arr_2, h_arr_2, sizeof(float) * N, cudaMemcpyHostToDevice);

	cudaMemcpy(&(dev_s->arr_1), &d_arr_1, sizeof(dev_s->arr_1), cudaMemcpyHostToDevice);
	cudaMemcpy(&(dev_s->arr_2), &d_arr_2, sizeof(dev_s->arr_2), cudaMemcpyHostToDevice);

	kernel<<<1,1>>>(dev_s);

	cudaMemcpy(h_arr_1, d_arr_1, N * sizeof(float), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_arr_2, d_arr_2, N * sizeof(float), cudaMemcpyDeviceToHost);

	std::cout << "arr 1: " << h_arr_1[1] << std::endl;
	std::cout << "arr 2: " << h_arr_2[1] << std::endl;

	cudaFree(d_arr_1);
	cudaFree(d_arr_2);

	free(h_arr_1);
	free(h_arr_2);

	cudaFree(dev_s);
}

